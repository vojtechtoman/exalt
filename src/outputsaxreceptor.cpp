/***************************************************************************
    outputsaxreceptor.cpp  -  Definition of OutputSAXReceptor class methods
                             -------------------
    begin                : October 24 2002
    copyright            : (C) 2003 by Vojtìch Toman
    email                : vtoman@lit.cz
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

/*!
  \file outputsaxreceptor.cpp
  \brief Definition of OutputSAXReceptor class methods.
  
  This file contains the definition of OutputSAXReceptor class methods.
*/

#ifdef __GNUG__
# pragma implementation
#endif


#include "outputsaxreceptor.h"


/*!
  Ensure that an instance of TextCodec exists. If it doesn't exist, a new instance is created.
 */
#define ENSURE_TEXT_CODEC_EXISTS	\
{					\
  if (!textCodec)			\
    createDefaultTextCodec();		\
}



/*!
  Output a string (must be zero terminated!) to the output device.

  \param str String for output.
 */
#define OUTPUT_TO_DEVICE(str)							\
{										\
  ENSURE_TEXT_CODEC_EXISTS;							\
  if (outputDevice)								\
    textCodec->output(outputDevice, str,					\
		      (Encodings::MIB)ExaltOptions::getOption(ExaltOptions::Encoding));	\
}



/*!
  Output a string of given length to the output device.

  \param str String for output.
  \param length The length of the string.
 */
#define OUTPUT_TO_DEVICE_LENGTH(str, length)					\
{										\
  ENSURE_TEXT_CODEC_EXISTS;							\
  if (outputDevice)								\
    textCodec->output(outputDevice, str, length,				\
		      (Encodings::MIB)ExaltOptions::getOption(ExaltOptions::Encoding));	\
}


/*!
  Output one character to the output device.

  \param c Character for output.
 */
#define OUTPUT_TO_DEVICE_CHAR(c)						\
{										\
  ENSURE_TEXT_CODEC_EXISTS;							\
  if (outputDevice)								\
    textCodec->output(outputDevice, c,						\
		      (Encodings::MIB)ExaltOptions::getOption(ExaltOptions::Encoding));	\
}




/*!
  Initialization of the receptor is performed by call to init(). The output device is set to NULL.
 */
OutputSAXReceptor::OutputSAXReceptor(void)
  : SAXReceptor(), UserOfTextCodec()
{
  outputDevice = 0;
  init();
}



/*!
  Initialization of the receptor is performed by call to init(). The output device is set to given device.

  \param outDevice The output device to be used by the receptor.
 */
OutputSAXReceptor::OutputSAXReceptor(IODevice *outDevice)
  : SAXReceptor(), UserOfTextCodec()
{
  outputDevice = outDevice;
  init();
}


/*!
  The instance of TextCodec is deleted.
 */
OutputSAXReceptor::~OutputSAXReceptor(void)
{
  deleteDefaultTextCodec();
}


/*!
  Initializes some state variables.
 */
void OutputSAXReceptor::init(void)
{
  dtdHasInternalSubset = false;
  inCDATA = false;
}



/*!
  Sets the output device used by the receptor for output.

  \param outDevice The output device.
 */
void OutputSAXReceptor::setOutputDevice(IODevice *outDevice)
{
  outputDevice = outDevice;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++



/*!
  Used for reporting error messages generated by Expat.
 */
void OutputSAXReceptor::reportError(void)
{
  FATAL("Output SAX receptor error!");
}



/*!
  Examines the name of the element and the values of its attributes and emits corresponding events to the XML model.

  \param userData Pointer to the user data structure.
  \param name Name of the element.
  \param attr An array of attributes

  \sa OutputSAXReceptor::exposeEvent()
 */
void OutputSAXReceptor::startElement(void *userData, const XmlChar *name, const XmlChar **attr)
{
  OUTPUT_TO_DEVICE("<");
  OUTPUT_TO_DEVICE(name);

//   DBG("<" << name << ">");
  if (attr)
    if (attr[0])
      {
	for (int i = 0; attr[i]; i += 2)
	  {
	    OUTPUT_TO_DEVICE(" ");
	    OUTPUT_TO_DEVICE(attr[i]);
	    OUTPUT_TO_DEVICE("=\"");
	    OUTPUT_TO_DEVICE(attr[i + 1]);
	    OUTPUT_TO_DEVICE("\"");

// 	    DBG(attr[i] << " = " << attr[i + 1]);
	  }
      }

  OUTPUT_TO_DEVICE(">");
}



/*!
  Examines the name of the element and emits corresponding event to the XML model.

  \param userData Pointer to the user data structure.
  \param name Name of the element.

  \sa OutputSAXReceptor::exposeEvent()
 */
void OutputSAXReceptor::endElement(void *userData,
				   const XmlChar *name)
{
  OUTPUT_TO_DEVICE("</");
  OUTPUT_TO_DEVICE(name);
  OUTPUT_TO_DEVICE(">");
}




/*!
  Examines the character data and emits an event to the XML model. If the data contain characters \&, ', ", \< or \>, these are substituted by corresponding entities (\&amp;, \&apos;, \&quot;, \&lt; or \&gt;).

  \param userData Pointer to the user data structure.
  \param data Character data.
  \param length Length of the data.

  \sa OutputSAXReceptor::exposeEvent()
 */
void OutputSAXReceptor::characterData(void *userData,
				      const XmlChar *data,
				      int length)
{
  if (!inCDATA)
    {
      //output character data and substitute XML's reserved entites
      for (int i = 0; i < length; i++)
	{
	  switch (data[i])
	    {
	    case AMP_REPLACEMENT:
	      //&gt;
	      OUTPUT_TO_DEVICE("&");
	      break;
	  
	    case '>':
	      //&gt;
	      OUTPUT_TO_DEVICE(ENT_GT);
	      break;
	  
	    case '<':
	      //&lt;
	      OUTPUT_TO_DEVICE(ENT_LT);
	      break;
	  
	    case '&':
	      //&amp;
	      OUTPUT_TO_DEVICE(ENT_AMP);
	      break;
	  
	    case '\'':
	      //&apos;
	      OUTPUT_TO_DEVICE(ENT_APOS);
	      break;
	  
	    case '\"':
	      //&quot;
	      OUTPUT_TO_DEVICE(ENT_QUOT);
	      break;
	  
	  
	  
	    default:
	      OUTPUT_TO_DEVICE_CHAR(data[i]);
	    }
	}
    }
  else
    //we are in CDATA --> no substitutions
    OUTPUT_TO_DEVICE_LENGTH(data, length);
}



/*!
  Examines the description of the processing instruction and outputs corresponding string to the output device.

  \param userData Pointer to the user data structure.
  \param target Target of the instruction.
  \param data Data of the instruction.
 */
void OutputSAXReceptor::processingInstruction(void *userData,
					      const XmlChar *target,
					      const XmlChar *data)
{
  OUTPUT_TO_DEVICE("<?");
  OUTPUT_TO_DEVICE(target);

  if (xmlchar_strlen(data))
    {
      OUTPUT_TO_DEVICE(" ");
      OUTPUT_TO_DEVICE(data);
    }
  OUTPUT_TO_DEVICE("?>");
}



/*!
  Outputs corresponding string to the output device.

  \param userData Pointer to the user data structure.
  \param data Data of the comment.
 */
void OutputSAXReceptor::comment(void *userData,
				const XmlChar *data)
{
  OUTPUT_TO_DEVICE("<!--");
  OUTPUT_TO_DEVICE(data);
  OUTPUT_TO_DEVICE("-->");
}



/*!
  Outputs corresponding string to the output device.

  \param userData Pointer to the user data structure.
 */
void OutputSAXReceptor::startCDATASection(void *userData)
{
  OUTPUT_TO_DEVICE("<![CDATA[");
  inCDATA = true;
}



/*!
  Outputs corresponding string to the output device.

  \param userData Pointer to the user data structure.
 */
void OutputSAXReceptor::endCDATASection(void *userData)
{
  OUTPUT_TO_DEVICE("]]>");
  inCDATA = false;
}



/*!
  Outputs the string of given length to the output device.

  \param userData Pointer to the user data structure.
  \param data The default data.
  \param length The length of the default data.
 */
void OutputSAXReceptor::defaultHandler(void *userData,
				       const XmlChar *data,
				       int length)
{
  OUTPUT_TO_DEVICE_LENGTH(data, length);
}



/*!
  Does nothing.

  \param unknownEncodingData The data structure describing the unknown encoding.
  \param name The name of the encoding.
  \param info The information about the encoding.

  \retval 1.
 */
int OutputSAXReceptor::unknownEncoding(void *unknownEncodingData,
				       const XmlChar *name,
				       XML_Encoding *info)
{
  return 1;
}



/*!
  Outputs the XML declaration to the output device.

  \param userData Pointer to the user data structure.
  \param version The XML version string.
  \param encoding The document encoding.
  \param standalone Is the document standalone?

 */
void OutputSAXReceptor::xmlDecl(void *userData,
				const XmlChar *version,
				const XmlChar *encoding,
				int standalone)
{
  OUTPUT_TO_DEVICE("<?xml");
  if (version)
    {
      OUTPUT_TO_DEVICE(" version=\"");
      OUTPUT_TO_DEVICE(version);
      OUTPUT_TO_DEVICE("\"");
    }

  if (encoding)
    {
      OUTPUT_TO_DEVICE(" encoding=\"");
      OUTPUT_TO_DEVICE(encoding);
      OUTPUT_TO_DEVICE("\"");
    }

  if (standalone != -1)
    {
      OUTPUT_TO_DEVICE(" standalone=\"");
      if (standalone)
	{
	  OUTPUT_TO_DEVICE("yes");
	}
      else
	{
	  OUTPUT_TO_DEVICE("no");
	}

      OUTPUT_TO_DEVICE("\"");
    }

  OUTPUT_TO_DEVICE("?>");
}



/*!
  Outputs the start of the DTD declaration.

  \param userData Pointer to the user data structure.
  \param doctypeName The name of the doctype.
  \param systemId The system id.
  \param publicId The public id.
  \param hasInternalSubset Has the DTD an internal subset?

 */
void OutputSAXReceptor::startDoctypeDecl(void *userData,
					 const XmlChar *doctypeName,
					 const XmlChar *systemId,
					 const XmlChar *publicId,
					 int hasInternalSubset)
{
  OUTPUT_TO_DEVICE("<!DOCTYPE ");
  OUTPUT_TO_DEVICE(doctypeName);

  if (publicId)
    {
      OUTPUT_TO_DEVICE(" PUBLIC \"");
      OUTPUT_TO_DEVICE(publicId);
      OUTPUT_TO_DEVICE("\"");
    }

  if (systemId)
    {
      if (!publicId)
	OUTPUT_TO_DEVICE(" SYSTEM");

      OUTPUT_TO_DEVICE(" \"");
      OUTPUT_TO_DEVICE(systemId);
      OUTPUT_TO_DEVICE("\"");
    }

  if (hasInternalSubset)
    {
      OUTPUT_TO_DEVICE(" [");
      dtdHasInternalSubset = true;
    }
  else
    dtdHasInternalSubset = false;

}



/*!
  Outputs the end the DTD declaration.

  \param userData Pointer to the user data structure.
 */
void OutputSAXReceptor::endDoctypeDecl(void *userData)
{
  if (dtdHasInternalSubset)
    {
      OUTPUT_TO_DEVICE("]");
      dtdHasInternalSubset = false;
    }

  OUTPUT_TO_DEVICE(">");
}




/*!
  Outputs the entity declaration.

  \param userData Pointer to the user data structure.
  \param entityName The name of the entity.
  \param isParameterEntity Is the entity a parameter entity?
  \param value The value of the entity.
  \param valueLength The length of the value.
  \param base The base.
  \param systemId The system id.
  \param publicId The public id.
  \param notationName The name of the notation.
 */
void OutputSAXReceptor::entityDecl(void *userData,
				   const XmlChar *entityName,
				   int isParameterEntity,
				   const XmlChar *value,
				   int valueLength,
				   const XmlChar *base,
				   const XmlChar *systemId,
				   const XmlChar *publicId,
				   const XmlChar *notationName)
{
  OUTPUT_TO_DEVICE("<!ENTITY ");

  if (isParameterEntity)
    OUTPUT_TO_DEVICE("% ");

  OUTPUT_TO_DEVICE(entityName);

  if (value)
    {
      OUTPUT_TO_DEVICE(" \"");
      OUTPUT_TO_DEVICE_LENGTH(value, valueLength);
      OUTPUT_TO_DEVICE("\"");
    }

  if (publicId)
    {
      OUTPUT_TO_DEVICE(" PUBLIC \"");
      OUTPUT_TO_DEVICE(publicId);
      OUTPUT_TO_DEVICE("\"");
    }

  if (systemId)
    {
      if (!publicId)
	OUTPUT_TO_DEVICE(" SYSTEM");

      OUTPUT_TO_DEVICE(" \"");
      OUTPUT_TO_DEVICE(systemId);
      OUTPUT_TO_DEVICE("\"");
    }

  if (notationName)
    {
      OUTPUT_TO_DEVICE(" NDATA ");
      OUTPUT_TO_DEVICE(notationName);
    }

  OUTPUT_TO_DEVICE(">");
}



/*!
  Outputs the notation declaration.

  \param userData Pointer to the user data structure.
  \param notationName The name of the notation.
  \param base The base.
  \param systemId The system id.
  \param publicId The public id.
 */
void OutputSAXReceptor::notationDecl(void *userData,
				     const XmlChar *notationName,
				     const XmlChar *base,
				     const XmlChar *systemId,
				     const XmlChar *publicId)
{
  OUTPUT_TO_DEVICE("<!NOTATION ");

  OUTPUT_TO_DEVICE(notationName);

  if (publicId)
    {
      OUTPUT_TO_DEVICE(" PUBLIC \"");
      OUTPUT_TO_DEVICE(publicId);
      OUTPUT_TO_DEVICE("\"");
    }

  if (systemId)
    {
      if (!publicId)
	OUTPUT_TO_DEVICE(" SYSTEM");

      OUTPUT_TO_DEVICE(" \"");
      OUTPUT_TO_DEVICE(systemId);
      OUTPUT_TO_DEVICE("\"");
    }

  OUTPUT_TO_DEVICE(">");
}

